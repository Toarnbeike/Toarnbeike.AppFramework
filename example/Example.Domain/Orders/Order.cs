using System.Collections.Immutable;
using Toarnbeike.AppFramework;
using Toarnbeike.AppFramework.Domain.Objects;
using Toarnbeike.AppFramework.Domain.Policies;
using Toarnbeike.AppFramework.Domain.Services;
using Toarnbeike.Example.Domain.Addresses;
using Toarnbeike.Example.Domain.Orders.Events;
using Toarnbeike.Example.Domain.Orders.Policies;
using Toarnbeike.Example.Domain.Shared;
using Toarnbeike.Results.Extensions;
using Toarnbeike.Unions;

namespace Toarnbeike.Example.Domain.Orders;

/// <summary>
/// Represents a customer order, including its unique identifier, shipping and billing addresses, line items, and current status.
/// </summary>
/// <remarks>
/// The order status determines the allowed operations and lifecycle of the order. All identifiers must
/// refer to valid entities in the system. The line items collection must not be null and typically contains at least
/// one item for a valid order.</remarks>
/// <param name="Id">The unique identifier for the order.</param>
/// <param name="ShippingAddress">The identifier of the address where the order will be shipped.</param>
/// <param name="BillingAddress">The identifier of the address used for billing purposes.</param>
/// <param name="LineItems">The collection of line items included in the order. Each line item specifies a product and quantity.</param>
/// <param name="OrderStatus">The current status of the order, which may be draft, confirmed, or shipped.</param>
public sealed record Order(OrderId Id, AddressId ShippingAddress, AddressId BillingAddress, ImmutableList<LineItem> LineItems, Union<Order.Draft, Order.Confirmed, Order.Shipped> OrderStatus)
    : IAggregate<OrderId>
{
    /// <summary>
    /// Gets the total monetary amount for all line items, including any applicable adjustments.
    /// </summary>
    /// <remarks>
    /// This is an example of a read-only property on the aggregate.
    /// Read-only properties should return their respective type, never results.
    /// The validity of the matching currencies of the line items should be checked before added the line item, and because they are checked, shouldn't lead to thowing on invalid currency here.
    /// </remarks>
    public Money TotalAmount => LineItems
            .Select(li => li.TotalPrice)
            .Aggregate((a, b) => a.Add(b));

    public static Result<Order> Create(Address shippingAddress, Address billingAddress, IEnumerable<LineItem> items)
    {
        var draft = new Order(
            Id: OrderId.New(),
            ShippingAddress: shippingAddress.Id,
            BillingAddress: billingAddress.Id,
            LineItems: [.. items],
            OrderStatus: Union<Draft, Confirmed, Shipped>.FromT1(new Draft()));

        var policy = new CompositePolicy<Order>(
            new LineItemCurrencyPolicy(),
            new LineItemUniquenessPolicy());

        return policy.Evaluate(draft).WithValue(draft);
    }

    /// <summary>
    /// Attempts to add the specified line item to the order if it satisfies the provided validation policy.
    /// </summary>
    /// <remarks>No domain events are generated by this operation.</remarks>
    /// <param name="item">The line item to add to the order. Cannot be null.</param>
    /// <param name="policy">The policy that determines whether the line item can be added. Cannot be null.</param>
    /// <returns>A result containing the new order state as a domain transition if the policy is satisfied; otherwise, a result
    /// indicating the failure.</returns>
    public Result<DomainTransition<Order>> AddLineItem(LineItem item)
    {
        var updated = this with
        {
            LineItems = LineItems.Add(item)
        };

        var policy = new CompositePolicy<Order>(
            new OrderModifyablePolicy(),            // order must have the correct status
            new LineItemCurrencyPolicy(),           // line items must have the correct currency
            new LineItemUniquenessPolicy());            // line items must be unique

        return policy.Evaluate(updated)
            .WithValue(DomainTransition<Order>.From(updated)); // no domain events are generated here.
    }

    /// <summary>
    /// Attempts to confirm the order if the specified confirmation policy is satisfied.
    /// </summary>
    /// <remarks>
    /// If the order is successfully confirmed, its status is updated and a confirmation event is generated.
    /// The confirmation timestamp is obtained from the provided date and time provider. 
    /// This method does not modify the original order instance; instead, it returns a new instance representing the confirmed state.
    /// </remarks>
    /// <param name="policy">The policy that determines whether the order can be confirmed. Must not be null.</param>
    /// <param name="dateTimeProvider">The provider used to obtain the current date and time for the confirmation timestamp. Must not be null.</param>
    /// <returns>A result containing a domain transition representing the confirmed order and the corresponding confirmation
    /// event if the policy is satisfied; otherwise, a failed result indicating why confirmation was not allowed.</returns>
    public Result<DomainTransition<Order>> Confirm(IDateTimeProvider dateTimeProvider)
    {
        var policy = new CompositePolicy<Order>(
            new OrderModifyablePolicy(),            // order must have the correct status
            new OrderNotEmptyPolicy());             // order must have at least 1 line item 

        return policy.Evaluate(this)
            .WithValue(this with
            {
                OrderStatus = Union<Draft, Confirmed, Shipped>.FromT2(new Confirmed(dateTimeProvider.Now))
            })
            .Map(confirmedOrder => DomainTransition<Order>.From(confirmedOrder, OrderConfirmed.Create(confirmedOrder, dateTimeProvider.Now)));
    }

    //Order status variants. With an upcoming Toarnbeike.Unions version, we can use source generators to create an OrderStatus class directly.
    public sealed record Draft;
    public sealed record Confirmed(DateTimeOffset ConfirmedAt);
    public sealed record Shipped(int ShippingId, DateTimeOffset ShippedAt);
}